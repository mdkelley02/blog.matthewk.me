{
  "id": "00000000",
  "date": "2023-04-25T00:09:02.291Z",
  "title": "Bootstrapping My Blog",
  "content": "# Source Code\n\n[https://github.com/mdkelley02/blog.matthewk.me](https://github.com/mdkelley02/blog.matthewk.me)\n\n# Introduction\n\nI wanted to explore ChatGPT and the mass hysteria that seems to surround it. I've noticed a lot of fearmongering online, especially on forums like r/CSCareerQuestions, and as someone who approaches new technologies with a healthy dose of skepticism, I wanted to take a closer look. Along the way, I learned a lot about ChatGPT and its potential benefits and drawbacks.\n\nMost of my job revolves around writing/debugging application layer code and configuring cloud resources, I want to see if a language model can outperform me.\n\nThe only appropriate way to test ChatGPT is to throw it into the programming mines. My goal was to have ChatGPT write as much code as possible to create, deploy, and automate my personal blog web app on AWS.\n\n## Components\n\n- **Backend**: AWS Lambda (Golang), API Gateway, S3 bucket for blog assets\n- **Frontend**: React SPA (TypeScript), Vite build tool, S3 bucket for static assets, CloudFront CDN\n\n## Architecture Diagram\n\n![Architecture Diagram](https://blog.matthewk.me/blog_architecture.png)\n\n# Lambda\n\nI'm going to start by creating the Go lambda code for getting from the bucket. This piece will sit behind the API gateway and serve articles from the S3 bucket. An article will be a JSON object with the string fields: id, title, date, content.\n\n### Prompt\n\nCreate a Golang AWS lambda handler using the AWS SDK (version 1) If at any point\nyou are about to reach your token response maximum, stop before the code segment\nand alert me.\n\nUse envconfig to parse environment variables for the S3 bucket name and AWS\nRegion. Use logrus for logging. Be sure to log errors and handle them gracefully.\n\nThere should be a package called handlers that exposes a Handler struct, this\nstruct will do routing in the lambda start function by calling a function Handle.\nHandle will select between one of three routes defined by API gateway each of\nthese reotues should be a function that takes a context and the api gatewayproxy\nrequest and returns the apigatewayproxyresponse and an error.\nThe endpoints will match these:\nconst (\n\tArticleRoute = \"/articles/{id}\"\n\tArticlesRoute = \"/articles\"\n\tHeartbeatRoute = \"/heartbeat\"\n)\n\nThe articles are as follows:\n\n- GET /heartbeat -> returns 200\n- GET /articles -> returns all articles\n- GET /articles/:articleId -> returns a single article or an error\n\nThere should be a package called store that exposes a struct S3Store that implements a GetArticles and a singular GetArticle, this should be a client\nfor S3.\n\nThe article object is JSON object in the bucket that follows this format.\n\ntype Article struct {\n\tId string `json:\"id\"`\n\tTitle string `json:\"title\"`\n\tContent string `json:\"content\"`\n\tDate string `json:\"date\"`\n}\n\n### Output\n\nLet's start by creating the Go module and importing necessary packages.\n\n1. Initialize the Go module:\n\n```bash\ngo mod init your_module_name\n```\n\n2. Install the required packages:\n\n```bash\ngo get -u github.com/aws/aws-lambda-go github.com/aws/aws-sdk-go github.com/sirupsen/logrus github.com/kelseyhightower/envconfig\n```\n\n3. [ ] Create a \"handlers\" package:\n    handlers/handler.go\n\n```go\npackage handlers\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/aws/aws-lambda-go/events\"\n)\n\nconst (\n\tArticleRoute   = \"/articles/{id}\"\n\tArticlesRoute  = \"/articles\"\n\tHeartbeatRoute = \"/heartbeat\"\n)\n\ntype Handler struct {\n\tstore Store\n}\n\ntype Store interface {\n\tGetArticles(ctx context.Context) ([]Article, error)\n\tGetArticle(ctx context.Context, id string) (*Article, error)\n}\n\nfunc NewHandler(store Store) *Handler {\n\treturn &Handler{store: store}\n}\n\nfunc (h *Handler) Handle(ctx context.Context, req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {\n\tswitch req.Path {\n\tcase HeartbeatRoute:\n\t\treturn h.heartbeat(ctx)\n\tcase ArticlesRoute:\n\t\treturn h.getArticles(ctx)\n\tcase ArticleRoute:\n\t\treturn h.getArticle(ctx, req.PathParameters[\"id\"])\n\tdefault:\n\t\treturn events.APIGatewayProxyResponse{}, errors.New(\"invalid route\")\n\t}\n}\n\n// Implement the three route handler functions here (heartbeat, getArticles, getArticle)\n\n```\n\n4. Create a \"store\" package:\n   store/s3_store.go\n\n```go\npackage store\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/s3\"\n\t\"github.com/sirupsen/logrus\"\n\t\"os\"\n)\n\ntype Config struct {\n\tBucketName string `envconfig:\"S3_BUCKET_NAME\"`\n\tRegion     string `envconfig:\"AWS_REGION\"`\n}\n\ntype S3Store struct {\n\ts3Client *s3.S3\n\tconfig   Config\n}\n\nfunc NewS3Store() (*S3Store, error) {\n\tvar config Config\n\terr := envconfig.Process(\"\", &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsess, err := session.NewSession(&aws.Config{\n\t\tRegion: aws.String(config.Region),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &S3Store{\n\t\ts3Client: s3.New(sess),\n\t\tconfig:   config,\n\t}, nil\n}\n\nfunc (s *S3Store) GetArticles(ctx context.Context) ([]Article, error) {\n\t// Implement fetching all articles from S3\n}\n\nfunc (s *S3Store) GetArticle(ctx context.Context, id string) (*Article, error) {\n\t// Implement fetching a single article from S3\n}\n```\n\n5. Define the main function to start the Lambda handler:\n   main.go\n\n```go\npackage main\n\nimport (\n\t\"github.com/aws/aws-lambda-go/lambda\"\n\t\"your_module_name/handlers\"\n\t\"your_module_name/store\"\n)\n\nfunc main() {\n\ts3Store, err := store.NewS3Store()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\thandler := handlers.NewHandler(s3Store)\n\tlambda.Start(handler.Handle)\n}\n\n```\n\n## Generating handlers/store Implementation\n\nNot bad, most of the stubs are generated. Let's see if it can do the handlers and the S3 calls.\n\n### Prompt\n\nalright, now, implement each of the calls to S3 as well as the handler functions.\nmake sure to log when necessary and gracefully handle the store not finding a\nbucket or any underlying AWS errors while making the call to the bucket.\n\n### Output\n\nI'll now implement the S3 calls and handler functions with error handling and logging.\n\nFirst, let's update the store/s3_store.go file with the GetArticles and GetArticle methods:\n\nstore/s3_store.go\n\n```go\npackage store\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/service/s3\"\n\t\"github.com/aws/aws-sdk-go/service/s3/s3manager\"\n\t\"github.com/sirupsen/logrus\"\n\t\"io/ioutil\"\n\t\"strings\"\n)\n\n// ... (Keep the previous code)\n\nfunc (s *S3Store) GetArticles(ctx context.Context) ([]Article, error) {\n\tlistObjectsInput := &s3.ListObjectsV2Input{\n\t\tBucket: aws.String(s.config.BucketName),\n\t}\n\tlistObjectsOutput, err := s.s3Client.ListObjectsV2WithContext(ctx, listObjectsInput)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to list objects: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tvar articles []Article\n\tfor _, obj := range listObjectsOutput.Contents {\n\t\tarticle, err := s.GetArticle(ctx, *obj.Key)\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tarticles = append(articles, *article)\n\t}\n\n\treturn articles, nil\n}\n\nfunc (s *S3Store) GetArticle(ctx context.Context, id string) (*Article, error) {\n\tgetObjectInput := &s3.GetObjectInput{\n\t\tBucket: aws.String(s.config.BucketName),\n\t\tKey:    aws.String(id),\n\t}\n\tgetObjectOutput, err := s.s3Client.GetObjectWithContext(ctx, getObjectInput)\n\tif err != nil {\n\t\tif aerr, ok := err.(awserr.Error); ok {\n\t\t\tswitch aerr.Code() {\n\t\t\tcase s3.ErrCodeNoSuchKey:\n\t\t\t\tlogrus.Warnf(\"Article not found: %s\", id)\n\t\t\t\treturn nil, errors.New(\"article not found\")\n\t\t\tdefault:\n\t\t\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tdefer getObjectOutput.Body.Close()\n\tbody, err := ioutil.ReadAll(getObjectOutput.Body)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to read article body: %v\", err)\n\t\treturn nil, err\n\t}\n\n\tvar article Article\n\terr = json.Unmarshal(body, &article)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to unmarshal article JSON: %v\", err)\n\t\treturn nil, err\n\t}\n\n\treturn &article, nil\n}\n\n```\n\nNow, let's update the handlers/handler.go file with the heartbeat, getArticles, and getArticle methods:\n\nhandlers/handler.go\n\n```go\npackage handlers\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/sirupsen/logrus\"\n\t\"net/http\"\n)\n\n// ... (Keep the previous code)\n\nfunc (h *Handler) getArticles(ctx context.Context) (events.APIGatewayProxyResponse, error) {\n\tarticles, err := h.store.GetArticles(ctx)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to get articles: %v\", err)\n\t\treturn events.APIGatewayProxyResponse{}, err\n\t}\n\n\tjsonData, err := json.Marshal(articles)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to marshal articles JSON: %v\", err)\n\t\treturn events.APIGatewayProxyResponse{}, err\n\t}\n\n\treturn events.APIGatewayProxyResponse{\n\t\tStatusCode: http.StatusOK,\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\tBody:       string(jsonData),\n\t}, nil\n}\n\nfunc (h *Handler) getArticle(ctx context.Context, id string) (events.APIGatewayProxyResponse, error) {\n\tarticle, err := h.store.GetArticle(ctx, id)\n\tif err != nil {\n\t\tif err.Error() == \"article not found\" {\n\t\t\treturn events.APIGatewayProxyResponse{\n\t\t\t\tStatusCode: http.StatusNotFound,\n\t\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\t\tBody:       \"Article not found\",\n\t\t\t}, nil\n\t\t}\n\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\treturn events.APIGatewayProxyResponse{}, err\n\t}\n\n\tjsonData, err := json.Marshal(article)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to marshal article JSON: %v\", err)\n\t\treturn events.APIGatewayProxyResponse{}, err\n\t}\n\n\treturn events.APIGatewayProxyResponse{\n\t\tStatusCode: http.StatusOK,\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\tBody:       string(jsonData),\n\t}, nil\n}\n\n```\n\n## Wait, That's Not Quite Right\n\nVery interesting response. Notice in the `getArticle` function, it is checking for the existence of an error that could not have possibly been created. I think we can get rid of that.\n\n```go\nif err.Error() == \"article not found\" {\n\treturn events.APIGatewayProxyResponse{\n\t\tStatusCode: http.StatusNotFound,\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\tBody:       \"Article not found\",\n\t}, nil\n}\n```\n\n### Prompt\n\nLook at how you implemented the store, there is no possible way an error of this type could exist. Why are you checking for this error inside the handler?\n\nif err.Error() == \"article not found\" {\n\treturn events.APIGatewayProxyResponse{\n\t\tStatusCode: http.StatusNotFound,\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\tBody:       \"Article not found\",\n\t}, nil\n}\n\nCan you fix this?\n\n### Output\n\nYou are correct; my previous implementation contained unnecessary error checks. I apologize for the confusion. I'll remove the check for the \"article not found\" error message in the handler and modify the error handling accordingly.\n\nUpdate the getArticle method in the handlers/handler.go file:\n\nhandlers/handler.go\n\n```go\npackage handlers\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/sirupsen/logrus\"\n\t\"net/http\"\n)\n\n// ... (Keep the previous code)\n\nfunc (h *Handler) getArticle(ctx context.Context, id string) (events.APIGatewayProxyResponse, error) {\n\tarticle, err := h.store.GetArticle(ctx, id)\n\tif err != nil {\n\t\tstatusCode := http.StatusInternalServerError\n\t\tif errors.Is(err, ErrArticleNotFound) {\n\t\t\tstatusCode = http.StatusNotFound\n\t\t} else {\n\t\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\t}\n\t\treturn events.APIGatewayProxyResponse{\n\t\t\tStatusCode: statusCode,\n\t\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\tBody:       err.Error(),\n\t\t}, nil\n\t}\n\n\tjsonData, err := json.Marshal(article)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to marshal article JSON: %v\", err)\n\t\treturn events.APIGatewayProxyResponse{}, err\n\t}\n\n\treturn events.APIGatewayProxyResponse{\n\t\tStatusCode: http.StatusOK,\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t\tBody:       string(jsonData),\n\t}, nil\n}\n```\n\nAdditionally, update the store/s3_store.go file to use a custom error for better error handling:\n\nstore/s3_store.go\n\n```go\npackage store\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t// ... (other imports)\n)\n\n// ... (Keep the previous code)\n\nvar ErrArticleNotFound = errors.New(\"article not found\")\n\nfunc (s *S3Store) GetArticle(ctx context.Context, id string) (*Article, error) {\n\t// ... (Keep the previous code)\n\n\tif aerr, ok := err.(awserr.Error); ok {\n\t\tswitch aerr.Code() {\n\t\tcase s3.ErrCodeNoSuchKey:\n\t\t\tlogrus.Warnf(\"Article not found: %s\", id)\n\t\t\treturn nil, ErrArticleNotFound\n\t\tdefault:\n\t\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tlogrus.Errorf(\"Failed to get article: %v\", err)\n\t\treturn nil, err\n\t}\n\n\t// ... (Keep the previous code)\n}\n\n```\n\nExcellent recovery on from ChatGPT. They even managed to handle the custom error in an idiomatic Go fashion. I'm impressed. At this point, ChatGPT has generated for us a workable piece of code that will handle our use case.\n\nI also decided to tweak the response type for getArticles to not return the string content to the caller. The content will only ever be sent when a user calls GetArticle.\n\n## Tweaks\n\nI ended up modifying the response from the Lambdas. `GetArticle` will return all the fields of the article, and the `GetArticles` function will return a partial not including the content.\n\n# React Client\n\n## Data Fetching\n\nWe are going to need a piece of code to make calls to our lambda, we also want to add a field for the amount of time it takes to read.\n\n### Prompt\n\nNext, create a react  hook in TypeScript to call this lambda. Call it\nuseArticles, create three functions on the hook. One for returning a single article, another for getting all the articles, and the last, an unexplored function the hook, calcReadTime which takes in. the content of the article and calculates the number of minutes it would take the average reader to read that many wpm. Create a type for getArticles that only has the id title and date, the date should be a date object which should be created when an article is retrieved. Make another type for the article from the lambda, which should match the type of article returned from the lambda function. Create a type for the article detail page which also deserializes the date string into a data object. In the case of an error the getArticle function should return null\n\n### Output\n\nsrc/hooks/useArticles\n\n```ts\nimport { useState, useEffect } from 'react';\n\nexport type Article = {\n  id: string;\n  title: string;\n  content: string;\n  date: string;\n};\n\ntype UseArticlesHook = {\n  getArticles: () => Promise<Article[]>;\n  getArticle: (id: string) => Promise<Article | null>;\n};\n\nconst useArticles = (): UseArticlesHook => {\n  const [apiUrl, setApiUrl] = useState<string>('');\n\n  useEffect(() => {\n    // Replace with your API Gateway URL\n    setApiUrl('https://your-api-gateway-url.execute-api.region.amazonaws.com');\n  }, []);\n\n  const getArticles = async (): Promise<Article[]> => {\n    try {\n      const response = await fetch(`${apiUrl}/articles`);\n      if (!response.ok) {\n        throw new Error('Failed to fetch articles');\n      }\n      const articles: Article[] = await response.json();\n      return articles;\n    } catch (error) {\n      console.error('Error fetching articles:', error);\n      return [];\n    }\n  };\n\n  const getArticle = async (id: string): Promise<Article | null> => {\n    try {\n      const response = await fetch(`${apiUrl}/articles/${id}`);\n      if (!response.ok) {\n        if (response.status === 404) {\n          return null;\n        }\n        throw new Error('Failed to fetch article');\n      }\n      const article: Article = await response.json();\n      return article;\n    } catch (error) {\n      console.error(`Error fetching article with id ${id}:`, error);\n      return null;\n    }\n  };\n\n  return { getArticles, getArticle };\n};\n\nexport default useArticles;\n\n```\n\nI ended up adding some additional types for a little more clarity. But now we have a hook that we can use to create our views.\n\n```ts\ntype GetArticleResponse = {\n\tid: string;\n\ttitle: string;\n\tcontent: string;\n\tdate: string;\n};\n\ntype GetArticlesResponse = {\n\tid: string;\n\ttitle: string;\n\tdate: string;\n}[];\n\nexport type Article = {\n\tid: string;\n\ttitle: string;\n\tcontent: string;\n\tdate: Date;\n\treadTime: number;\n};\n\nexport type ArticlePartial = {\n\tid: string;\n\ttitle: string;\n\tdate: Date;\n};\n```\n\n## Color Scheme hook\n\nNext I want to add dark mode to the app, I am going to use SCSS variables for this. To set the state for the scheme I am going to persist the value into `localStorage`. When the hook is created I am going to check `localStorage` if the scheme key exists, otherwise I will look in the user's system theme for their preferred scheme. I will be using a data attribute on the HTML element to decide in my SCSS which namespace of colors to use based on what this hook returns.\n\n### Prompt\n\nCreate a React hook in TypeScript called `useTheme` that manages the application's theme, including dark and light modes. The hook should provide functionality to toggle between dark and light themes, and apply appropriate styles, icons, and Markdown code themes based on the current theme. It should also use local storage to save the user's theme preference and set the theme based on the user's system preference if no saved theme is found.\n\n### Output\n\ncreate the `useTheme` hook:\n\nsrc/hooks/useTheme.ts\n\n```ts\nimport { useState, useEffect } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\nconst Themes = ['dark', 'light'] as const;\nexport type ThemeColor = typeof Themes[number];\n\nconst ThemeDataAttr = 'data-theme';\nconst ThemeElementSelector = 'html';\nconst ThemeElement = document.querySelector(ThemeElementSelector);\n\nexport function useTheme() {\n  const [theme, setTheme] = useState<ThemeColor>('light');\n  const [savedTheme, setSavedTheme] = useLocalStorage<ThemeColor>('theme', 'dark');\n\n  function getSystemTheme(): ThemeColor {\n    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n  }\n\n  function applyTheme(theme: ThemeColor) {\n    ThemeElement?.setAttribute(ThemeDataAttr, theme);\n    setTheme(theme);\n    setSavedTheme(theme);\n  }\n\n  function toggleTheme() {\n    applyTheme(theme === 'dark' ? 'light' : 'dark');\n  }\n\n  useEffect(() => {\n    applyTheme(savedTheme || getSystemTheme());\n  }, []);\n\n  return [theme, toggleTheme] as const;\n}\n```\n\nNow, let's create the `useLocalStorage` hook:\n\nsrc/hooks/useLocalStorage.ts\n\n```ts\nimport { useState } from 'react';\n\nexport function useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.log('Error reading from local storage:', error);\n      return initialValue;\n    }\n  });\n\n  const setValue = (value: T) => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.log('Error writing to local storage:', error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n```\n\nWe now have a color theme and a way to access our data. Next, we need to create a view for viewing all the articles and another for the article detail. Since we are using Markdown to write the articles and serializing them into a string, we need a Markdown parser. I want to use `react-markdown`\n\n## Article View\n\n### Prompt\n\nNow, create another view called ArticleDetail that will use react markdown to parse the article string and render it as a react component. it will take the full article type including the time to read\n\n### Output\n\nFirst, install the `react-markdown` package:\n\n```bash\nnpm i react-markdown\n```\n\nNow, let's create the `ArticleDetail` component:\n\nsrc/components/ArticleDetail.tsx\n\n```ts\nimport React from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport { Article } from '../types';\n\ntype ArticleDetailProps = {\n  article: Article;\n};\n\nconst ArticleDetail: React.FC<ArticleDetailProps> = ({ article }) => {\n  return (\n    <div>\n      <h1>{article.title}</h1>\n      <p>{article.date.toLocaleDateString()}</p>\n      <p>Time to read: {article.readTime} minutes</p>\n      <ReactMarkdown>{article.content}</ReactMarkdown>\n    </div>\n  );\n};\n\nexport default ArticleDetail;\n```\n\n## Articles View\n\n### Prompt\n\nNext create a view in that uses the useArticles hook to look at all the articles. create a react functional component that will fetch all the articles and set it as state, then render it to the browser using another functional component that just displays the article content. it will be an article partial and look like this.\n\n```ts\nexport type ArticlePartial = { id: string; title: string; date: Date; };\n```\n\n### Output\n\n```ts\nimport React from 'react';\nimport { ArticleListItem } from '../types';\n\ntype ArticlePartialProps = {\n  article: ArticleListItem;\n};\n\nconst ArticlePartial: React.FC<ArticlePartialProps> = ({ article }) => {\n  return (\n    <div>\n      <h2>{article.title}</h2>\n      <p>{article.date.toLocaleDateString()}</p>\n    </div>\n  );\n};\n\nexport default ArticlePartial;\n```\n\n```ts\nimport React, { useState, useEffect } from 'react';\nimport useArticles from '../hooks/useArticles';\nimport ArticlePartial from './ArticlePartial';\nimport { ArticleListItem } from '../types';\n\nconst ArticlesView: React.FC = () => {\n  const [articles, setArticles] = useState<ArticleListItem[]>([]);\n  const { getArticles } = useArticles();\n\n  useEffect(() => {\n    const fetchArticles = async () => {\n      const fetchedArticles = await getArticles();\n      setArticles(fetchedArticles);\n    };\n\n    fetchArticles();\n  }, [getArticles]);\n\n  return (\n    <div>\n      <h1>Articles</h1>\n      {articles.map((article) => (\n        <ArticlePartial key={article.id} article={article} />\n      ))}\n    </div>\n  );\n};\n\nexport default ArticlesView;\n```\n\n# Deployment\n\n## Terraform\n\nAfter witnessing ChatGPT's remarkable prowess in tackling Go and React, you might be feeling apprehensive about your chosen field, or even frantically searching for alternative careers, like coal mining. Fortunately, I have good news for you. ChatGPT is entirely incapable of generating functional Terraform code. I invested so much time attempting to deploy a project using solely ChatGPT-generated code that I eventually decided to omit this portion of the project.\n\nThe AWS Terraform provider, which encapsulates the AWS API for users to access, changes on a daily basis. ChatGPT is not trained regularly, so it only has knowledge of a stale version of the AWS terraform provider. I found that trying to get ChatGPT to generate code from an unstable and stale API was akin to guiding someone with advanced dementia through the process of writing an autobiography.\n\nI ended up writing all the Terraform myself. If you are curious about how to set up an API gateway or deploy your SPA with global caching be sure to check out the source code.\n\n# Conclusion\n\nWas I successful in achieving my goal? Not quite, I conceded defeat with Terraform. However, did I gain valuable insights along the way? Absolutely. While it may not be suitable for Terraform, ChatGPT excels at providing solutions to well-defined problems. It's particularly adept at handling application layer code and effectively assists in learning about widely understood concepts. Though I can only really speak to its software-writing capabilities, as a language model, ChatGPT outperforms probably 90% of Americans when it comes to composition. It begs the question: Did I even write this? 🤔\n\n## Personal Takeaway\n\n- No, ChatGPT isn't going to take your job. Anyone suggesting otherwise should reassess their grasp of software development. We're not paid to vomit application code, but rather to design and solve problems at a much more macro level. I will be sure to redact this opinion and pickup my coal mining pickaxe once ChatGPT can architect an entire solution for a programming problem.\n- I don't think ChatGPT is capable of enabling an average non-technical person to write a complete full-fledged application, but it certainly can help with generating application layer snippets. If someone with no technical background were able to do so using ChatGPT, I'd be genuinely impressed by their determination. But right now, I don't think it would be possible for someone without solid experience in programming to achieve what a developer can do without ChatGPT.\n- ChatGPT can aid in learning about certain widely-known, well-understood, and documented issues. However, I would exercise caution before treating it as the ultimate authority. If you're set on using ChatGPT to learn something, ask the model for a high-level explanation first, and then delve into the resulting points in greater detail using more reliable sources.\n- ChatGPT is incredibly adept at handling Leetcode style questions and excels at writing single functions, particularly those that are algorithmic in nature. Need to learn how to write a JavaScript deepEquals() function? Want to merge k sorted lists? ChatGPT will be your best friend. However, it still cannot compose together software to create a \"system\".\n- It's worth considering the implications of using ChatGPT, particularly in a work setting, where sharing instructions with a data company might expose your intellectual property. As more and more generative AI tools emerge daily, it's important to consider the origins of their data. ChatGPT and similar tools, like GitHub Copilot, have been known to copy code verbatim: [https://www.reddit.com/r/technology/comments/ylfd6n/weve_filed_a_lawsuit_challenging_github_copilot/](https://www.reddit.com/r/technology/comments/ylfd6n/weve_filed_a_lawsuit_challenging_github_copilot/)\n"
}